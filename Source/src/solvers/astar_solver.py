from __types import Grid
from utils import (
    check_hashi,
    encode_hashi,
    extract_solution,
    generate_output,
    validate_solution,
)
import heapq
import traceback


def compute_heuristic(cnf, assignment):
    """
    Compute the heuristic value for a given partial assignment.
    The heuristic is defined as the number of clauses that have all literals
    assigned but are not satisfied.
    
    :param cnf: CNF object with a 'clauses' attribute.
    :param assignment: Dictionary mapping variable to its boolean value.
    :return: Heuristic value as an integer.
    """
    h = 0
    for clause in cnf.clauses:
        all_assigned = True
        clause_satisfied = False
        for lit in clause:
            var = abs(lit)
            if var not in assignment:
                all_assigned = False
                break
            else:
                val = assignment[var]
                if (lit > 0 and val) or (lit < 0 and not val):
                    clause_satisfied = True
                    break
        if all_assigned and not clause_satisfied:
            h += 1
    return h


def is_clause_violated(clause, assignment):
    """
    Check whether a clause is violated by the current assignment.
    A clause is considered violated if all of its variables are assigned
    and none of its literals evaluates to True.
    
    :param clause: List of integers representing the clause's literals.
    :param assignment: Current assignment dictionary.
    :return: True if clause is violated, False otherwise.
    """
    all_assigned = True
    clause_satisfied = False
    for lit in clause:
        var = abs(lit)
        if var not in assignment:
            all_assigned = False
            break
        else:
            val = assignment[var]
            if (lit > 0 and val) or (lit < 0 and not val):
                clause_satisfied = True
                break
    return all_assigned and not clause_satisfied


def is_complete_assignment(assignment, variables):
    """
    Check if the assignment is complete (i.e., all variables have been assigned).
    
    :param assignment: Current assignment dictionary.
    :param variables: List of all variables.
    :return: True if complete, False otherwise.
    """
    return len(assignment) == len(variables)


def check_full_assignment(cnf, assignment):
    """
    Verify that a complete assignment satisfies all clauses in the CNF.
    
    :param cnf: CNF object with a 'clauses' attribute.
    :param assignment: A complete assignment dictionary.
    :return: True if all clauses are satisfied, False otherwise.
    """
    for clause in cnf.clauses:
        clause_satisfied = False
        for lit in clause:
            var = abs(lit)
            val = assignment[var]
            if (lit > 0 and val) or (lit < 0 and not val):
                clause_satisfied = True
                break
        if not clause_satisfied:
            return False
    return True


def expand_state(cnf, variables, level, assignment):
    """
    Expand the current state by assigning the next variable with both possible values.
    Prune any branch where a clause is already violated.
    
    :param cnf: CNF object with a 'clauses' attribute.
    :param variables: Sorted list of variables.
    :param level: Current level (number of variables assigned).
    :param assignment: Current assignment dictionary.
    :return: List of tuples (new_level, new_assignment) that are valid for expansion.
    """
    next_states = []
    current_var = variables[level]
    for value in [False, True]:
        new_assignment = assignment.copy()
        new_assignment[current_var] = value

        # Prune the state if any clause is violated
        violated = False
        for clause in cnf.clauses:
            if is_clause_violated(clause, new_assignment):
                violated = True
                break
        if not violated:
            next_states.append((level + 1, new_assignment))
    return next_states


def solve_with_astar(grid: Grid):
    """
    Solve the Hashi puzzle by encoding it into a CNF and then solving the CNF
    using the A* search algorithm. The CNF encoding remains unchanged.
    
    :param grid: Grid object representing the Hashi puzzle.
    :return: The final output generated by the solution if found, or an empty string.
    """
    try:
        cnf, edge_vars, islands, _ = encode_hashi(grid, use_pysat=True)

        # Handle case where there are no islands
        if not islands:
            if check_hashi([], []):
                return generate_output(grid, [], [])
            else:
                return ""

        if not hasattr(cnf, 'clauses') or not cnf.clauses:
            print("Error: CNF object does not contain clauses.")
            return ""

        # Retrieve and sort the unique variables from the CNF
        variables = sorted(set(abs(lit) for clause in cnf.clauses for lit in clause))
        total_combinations = 2 ** len(variables)
        print(f"Total unique variables in clauses: {len(variables)}")
        print(f"Total clauses: {len(cnf.clauses)}")
        print(f"Total combinations to check (full assignments): {total_combinations:,}")

        if len(variables) > 22:
            print(f"Warning: {len(variables)} variables ({total_combinations:,} combinations) is likely too large for A* search.")

        # Initialize the priority queue for A* search.
        # Each state is a tuple (f, level, counter, assignment) where f = level (g) + heuristic (h)
        open_list = []
        initial_assignment = {}
        initial_level = 0
        counter = 0  # Tie-breaker counter
        initial_f = initial_level + compute_heuristic(cnf, initial_assignment)
        heapq.heappush(open_list, (initial_f, initial_level, counter, initial_assignment))
        nodes_expanded = 0

        # A* search loop
        while open_list:
            f, level, _, assignment = heapq.heappop(open_list)
            nodes_expanded += 1

            # If the assignment is complete, verify if it satisfies all clauses.
            if is_complete_assignment(assignment, variables):
                if check_full_assignment(cnf, assignment):
                    print(f"\nFound a satisfying complete assignment after expanding {nodes_expanded:,} nodes.")
                    model = [var if assignment[var] else -var for var in variables]
                    if validate_solution(islands, edge_vars, model):
                        print("Satisfying assignment passed validation.")
                        hashi_solution = extract_solution(model, edge_vars)
                        if check_hashi(islands, hashi_solution):
                            print("Solution extracted and passed final check_hashi.")
                            return generate_output(grid, islands, hashi_solution)
                        else:
                            print("Warning: Solution failed final check_hashi despite satisfying CNF and validation.")
                continue

            # Expand the current state to generate new states.
            for new_level, new_assignment in expand_state(cnf, variables, level, assignment):
                h_value = compute_heuristic(cnf, new_assignment)
                new_f = new_level + h_value
                counter += 1  # Increment the tie-breaker counter for each new state
                heapq.heappush(open_list, (new_f, new_level, counter, new_assignment))

            if nodes_expanded % 100000 == 0:
                print(f"Expanded {nodes_expanded:,} nodes so far...", end="\r")

        print(f"\nExpanded all nodes ({nodes_expanded:,}) without finding a valid solution.")
        return ""

    except KeyboardInterrupt:
        print("\n> Terminating...")
        return ""
    except AttributeError:
        print("\nError: encode_hashi might not have returned a CNF object with '.clauses'. Check return type.")
        return ""
    except Exception as e:
        print(f"\nAn unexpected error occurred: {e}")
        print(traceback.format_exc())
        return ""
